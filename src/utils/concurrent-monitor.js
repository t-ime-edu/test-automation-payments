import { Logger } from './logger.js';
import { KoreanReportGenerator } from './korean-report-generator.js';
import fs from 'fs';
import path from 'path';

/**
 * ÎèôÏ†ë ÌÖåÏä§Ìä∏Ïö© Ïã§ÏãúÍ∞Ñ Î™®ÎãàÌÑ∞ÎßÅ ÌÅ¥ÎûòÏä§
 * 400Î™Ö ÎèôÏ†ë ÌÖåÏä§Ìä∏ Ïãú Ïã§ÏãúÍ∞Ñ ÏÉÅÌÉú Ï∂îÏ†Å
 */
export class ConcurrentMonitor {
  constructor(testName = 'concurrent-test') {
    this.testName = testName;
    this.logger = new Logger('ConcurrentMonitor');
    this.startTime = Date.now();

    // ÌÜµÍ≥Ñ Îç∞Ïù¥ÌÑ∞
    this.stats = {
      total: 0,
      running: 0,
      completed: 0,
      failed: 0,
      waiting: 0, // ÎåÄÍ∏∞ ÌéòÏù¥ÏßÄÏóê Í±∏Î¶∞ ÏÑ∏ÏÖò Ïàò
      stepStats: {
        'step1-course': 0,
        'step2-basic': 0,
        'step3-detailed': 0,
        'step4-class': 0,
        'step5-payment': 0
      },
      errorsByStep: {},
      errorsByType: {},
      waitingPageEncounters: 0, // ÎåÄÍ∏∞ ÌéòÏù¥ÏßÄ Î∞úÏÉù ÌöüÏàò
      avgWaitTime: 0
    };

    // ÏÑ∏ÏÖòÎ≥Ñ ÏÉÅÌÉú Ï∂îÏ†Å
    this.sessions = new Map();

    // Î°úÍ∑∏ ÌååÏùº ÏÑ§Ï†ï - ÎÇ†ÏßúÎ≥Ñ Ìè¥Îçî + ÌÖåÏä§Ìä∏Î≥Ñ Ìè¥ÎçîÎ°ú Ï†ïÎ¶¨
    const now = new Date();
    const dateStr = now.toISOString().split('T')[0]; // YYYY-MM-DD
    const timeStr = now.toTimeString().split(' ')[0].replace(/:/g, '-'); // HH-MM-SS

    // ÎÇ†ÏßúÎ≥Ñ Ìè¥Îçî + ÌÖåÏä§Ìä∏Î≥Ñ Ìè¥Îçî ÏÉùÏÑ± (Ïòà: reports/monitoring/2025-10-15/10-30-45-multi-test-2/)
    const testDirName = `${timeStr}-${testName}`;
    this.logDir = path.join(process.cwd(), 'reports', 'monitoring', dateStr, testDirName);
    this.ensureLogDirectory();

    this.logFile = path.join(this.logDir, 'test.log');
    this.statsFile = path.join(this.logDir, 'stats.json');

    // Ïã§ÏãúÍ∞Ñ Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûë
    this.startMonitoring();
  }

  /**
   * Î°úÍ∑∏ ÎîîÎ†âÌÜ†Î¶¨ ÏÉùÏÑ±
   */
  ensureLogDirectory() {
    if (!fs.existsSync(this.logDir)) {
      fs.mkdirSync(this.logDir, { recursive: true });
    }
  }

  /**
   * Ïã§ÏãúÍ∞Ñ Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûë
   */
  startMonitoring() {
    this.monitorInterval = setInterval(() => {
      this.printStatus();
      this.saveStats();
    }, 5000); // 5Ï¥àÎßàÎã§ ÏÉÅÌÉú Ï∂úÎ†•

    this.logger.info('üöÄ Concurrent monitoring started');
    this.logger.info(`Log file: ${this.logFile}`);
    this.logger.info(`Stats file: ${this.statsFile}`);
  }

  /**
   * Î™®ÎãàÌÑ∞ÎßÅ Ï§ëÏßÄ
   */
  async stopMonitoring() {
    if (this.monitorInterval) {
      clearInterval(this.monitorInterval);
      this.monitorInterval = null;
    }

    // ÏµúÏ¢Ö ÌÜµÍ≥Ñ Ï†ÄÏû•
    this.printFinalReport();
    this.saveStats();

    // ÌïúÍ∏Ä Î≥¥Í≥†ÏÑú ÏÉùÏÑ±
    await this.generateKoreanReport();

    this.logger.info('üèÅ Concurrent monitoring stopped');
  }

  /**
   * ÌïúÍ∏Ä Î≥¥Í≥†ÏÑú ÏÉùÏÑ±
   */
  async generateKoreanReport() {
    try {
      const reportGenerator = new KoreanReportGenerator();
      const reportPath = reportGenerator.generateReport(this.statsFile);
      this.logger.info(`üìÑ ÌïúÍ∏Ä Î≥¥Í≥†ÏÑú: ${reportPath}`);
      console.log(`\nüìÑ ÌïúÍ∏Ä Î≥¥Í≥†ÏÑúÍ∞Ä ÏÉùÏÑ±ÎêòÏóàÏäµÎãàÎã§: ${reportPath}\n`);
    } catch (error) {
      this.logger.error('ÌïúÍ∏Ä Î≥¥Í≥†ÏÑú ÏÉùÏÑ± Ïã§Ìå®:', error);
    }
  }

  /**
   * ÏÑ∏ÏÖò Îì±Î°ù
   */
  registerSession(sessionId, metadata = {}) {
    this.sessions.set(sessionId, {
      sessionId,
      status: 'registered',
      currentStep: 'init',
      startTime: Date.now(),
      errors: [],
      waitingEncountered: false,
      waitTime: 0,
      ...metadata
    });

    this.stats.total++;
    this.logEvent('SESSION_REGISTERED', { sessionId, total: this.stats.total });
  }

  /**
   * ÏÑ∏ÏÖò ÏãúÏûë
   */
  startSession(sessionId) {
    const session = this.sessions.get(sessionId);
    if (session) {
      session.status = 'running';
      session.actualStartTime = Date.now();
      this.stats.running++;

      this.logEvent('SESSION_STARTED', { sessionId, running: this.stats.running });
    }
  }

  /**
   * ÏÑ∏ÏÖò Îã®Í≥Ñ ÏóÖÎç∞Ïù¥Ìä∏
   */
  updateSessionStep(sessionId, step) {
    const session = this.sessions.get(sessionId);
    if (session) {
      session.currentStep = step;
      session.lastStepTime = Date.now();

      this.stats.stepStats[step] = (this.stats.stepStats[step] || 0) + 1;

      this.logEvent('STEP_UPDATE', { sessionId, step });
    }
  }

  /**
   * ÎåÄÍ∏∞ ÌéòÏù¥ÏßÄ Î∞úÏÉù Í∏∞Î°ù
   */
  recordWaitingPage(sessionId, waitTime, queuePosition) {
    const session = this.sessions.get(sessionId);
    if (session) {
      session.waitingEncountered = true;
      session.waitTime = waitTime;
      session.queuePosition = queuePosition;

      this.stats.waiting++;
      this.stats.waitingPageEncounters++;
      this.stats.avgWaitTime = ((this.stats.avgWaitTime * (this.stats.waitingPageEncounters - 1)) + waitTime) / this.stats.waitingPageEncounters;

      this.logEvent('WAITING_PAGE', {
        sessionId,
        waitTime,
        queuePosition,
        totalWaiting: this.stats.waiting,
        avgWaitTime: Math.round(this.stats.avgWaitTime)
      });
    }
  }

  /**
   * ÎåÄÍ∏∞ ÌéòÏù¥ÏßÄ ÌÜµÍ≥º Í∏∞Î°ù
   */
  recordWaitingPagePassed(sessionId) {
    const session = this.sessions.get(sessionId);
    if (session && session.waitingEncountered) {
      this.stats.waiting = Math.max(0, this.stats.waiting - 1);

      this.logEvent('WAITING_PASSED', { sessionId, remainingWaiting: this.stats.waiting });
    }
  }

  /**
   * ÏÑ∏ÏÖò ÏôÑÎ£å
   */
  completeSession(sessionId, success = true, result = {}) {
    const session = this.sessions.get(sessionId);
    if (session) {
      session.status = success ? 'completed' : 'failed';
      session.endTime = Date.now();
      session.duration = session.endTime - (session.actualStartTime || session.startTime);
      session.result = result;

      this.stats.running = Math.max(0, this.stats.running - 1);

      if (success) {
        this.stats.completed++;
        this.logEvent('SESSION_COMPLETED', {
          sessionId,
          duration: session.duration,
          completed: this.stats.completed
        });
      } else {
        this.stats.failed++;
        this.logEvent('SESSION_FAILED', {
          sessionId,
          duration: session.duration,
          failed: this.stats.failed,
          errors: session.errors
        });
      }
    }
  }

  /**
   * ÏóêÎü¨ Í∏∞Î°ù
   */
  recordError(sessionId, step, error) {
    const session = this.sessions.get(sessionId);
    if (session) {
      session.errors.push({
        step,
        message: error.message || error,
        timestamp: Date.now()
      });

      // Îã®Í≥ÑÎ≥Ñ ÏóêÎü¨ ÏßëÍ≥Ñ
      this.stats.errorsByStep[step] = (this.stats.errorsByStep[step] || 0) + 1;

      // ÏóêÎü¨ ÌÉÄÏûÖÎ≥Ñ ÏßëÍ≥Ñ
      const errorType = this.categorizeError(error.message || error);
      this.stats.errorsByType[errorType] = (this.stats.errorsByType[errorType] || 0) + 1;

      this.logEvent('ERROR', {
        sessionId,
        step,
        error: error.message || error,
        errorType
      });
    }
  }

  /**
   * ÏóêÎü¨ Î∂ÑÎ•ò
   */
  categorizeError(errorMessage) {
    if (!errorMessage) return 'Unknown';

    const msg = errorMessage.toLowerCase();

    if (msg.includes('timeout')) return 'Timeout';
    if (msg.includes('waiting') || msg.includes('queue')) return 'WaitingPage';
    if (msg.includes('network') || msg.includes('connection')) return 'Network';
    if (msg.includes('element') || msg.includes('selector')) return 'UIElement';
    if (msg.includes('navigation')) return 'Navigation';
    if (msg.includes('click')) return 'Click';

    return 'Other';
  }

  /**
   * Ïù¥Î≤§Ìä∏ Î°úÍ∑∏ Í∏∞Î°ù
   */
  logEvent(eventType, data) {
    const timestamp = new Date().toISOString();
    const elapsed = Date.now() - this.startTime;

    const logEntry = {
      timestamp,
      elapsed: Math.round(elapsed / 1000),
      eventType,
      ...data
    };

    // ÌååÏùºÏóê Î°úÍ∑∏ Ï∂îÍ∞Ä
    const logLine = JSON.stringify(logEntry) + '\n';
    fs.appendFileSync(this.logFile, logLine);
  }

  /**
   * Ïã§ÏãúÍ∞Ñ ÏÉÅÌÉú Ï∂úÎ†•
   */
  printStatus() {
    const elapsed = Math.round((Date.now() - this.startTime) / 1000);
    const successRate = this.stats.total > 0
      ? ((this.stats.completed / this.stats.total) * 100).toFixed(1)
      : 0;

    console.log('\n' + '='.repeat(80));
    console.log(`üìä CONCURRENT TEST STATUS (${elapsed}s elapsed)`);
    console.log('='.repeat(80));
    console.log(`Total: ${this.stats.total} | Running: ${this.stats.running} | Completed: ${this.stats.completed} | Failed: ${this.stats.failed}`);
    console.log(`Success Rate: ${successRate}% | Waiting: ${this.stats.waiting} users`);

    if (this.stats.waitingPageEncounters > 0) {
      console.log(`‚è≥ Waiting Page: ${this.stats.waitingPageEncounters} encounters, Avg wait: ${Math.round(this.stats.avgWaitTime)}s`);
    }

    if (Object.keys(this.stats.errorsByType).length > 0) {
      console.log('\nüö® Error Summary:');
      Object.entries(this.stats.errorsByType)
        .sort(([, a], [, b]) => b - a)
        .slice(0, 5)
        .forEach(([type, count]) => {
          console.log(`  ${type}: ${count}`);
        });
    }

    console.log('='.repeat(80) + '\n');
  }

  /**
   * ÏµúÏ¢Ö Î≥¥Í≥†ÏÑú Ï∂úÎ†•
   */
  printFinalReport() {
    const elapsed = Math.round((Date.now() - this.startTime) / 1000);
    const successRate = this.stats.total > 0
      ? ((this.stats.completed / this.stats.total) * 100).toFixed(2)
      : 0;

    console.log('\n' + '='.repeat(80));
    console.log('üèÅ FINAL TEST REPORT');
    console.log('='.repeat(80));
    console.log(`Test Duration: ${elapsed}s (${Math.round(elapsed / 60)}m ${elapsed % 60}s)`);
    console.log(`Total Sessions: ${this.stats.total}`);
    console.log(`Completed: ${this.stats.completed} (${successRate}%)`);
    console.log(`Failed: ${this.stats.failed}`);
    console.log(`\n‚è≥ Waiting Page Statistics:`);
    console.log(`  Encounters: ${this.stats.waitingPageEncounters}`);
    console.log(`  Average Wait Time: ${Math.round(this.stats.avgWaitTime)}s`);

    if (Object.keys(this.stats.errorsByStep).length > 0) {
      console.log('\nüìä Errors by Step:');
      Object.entries(this.stats.errorsByStep)
        .sort(([, a], [, b]) => b - a)
        .forEach(([step, count]) => {
          console.log(`  ${step}: ${count}`);
        });
    }

    if (Object.keys(this.stats.errorsByType).length > 0) {
      console.log('\nüö® Errors by Type:');
      Object.entries(this.stats.errorsByType)
        .sort(([, a], [, b]) => b - a)
        .forEach(([type, count]) => {
          console.log(`  ${type}: ${count}`);
        });
    }

    console.log('='.repeat(80) + '\n');

    this.logger.info(`Final report saved to: ${this.statsFile}`);
  }

  /**
   * ÌÜµÍ≥Ñ Ï†ÄÏû•
   */
  saveStats() {
    const statsData = {
      testName: this.testName,
      startTime: this.startTime,
      currentTime: Date.now(),
      elapsed: Date.now() - this.startTime,
      stats: this.stats,
      sessions: Array.from(this.sessions.values())
    };

    fs.writeFileSync(this.statsFile, JSON.stringify(statsData, null, 2));
  }

  /**
   * ÌÜµÍ≥Ñ Í∞ÄÏ†∏Ïò§Í∏∞
   */
  getStats() {
    return {
      ...this.stats,
      elapsed: Date.now() - this.startTime,
      successRate: this.stats.total > 0
        ? ((this.stats.completed / this.stats.total) * 100).toFixed(2)
        : 0
    };
  }
}
